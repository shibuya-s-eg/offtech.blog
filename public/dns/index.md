# DNSを完全に理解する


<!--
Todo:
- TLDR

-->



こんにちは、しぶやです。
今回はDNSを完全に理解していきます。

本記事では、Linuxをベースに説明を行いますが、本質的な部分はWindowsにも通じる話だと思います。

## TL;DR

* 世の中DNSの動きを追うときはICANN、レジストリ、レジストラ、権威DNSサーバ、キャッシュDNSサーバが登場する。
* DNSレコードの目的と内容を理解しよう。
* DNSは基本的にUDP通信であるため、攻撃に利用されやすいので、それぞれの攻撃と対策を理解しよう。


## 0　はじめに

読者のみなさんはDNSについて、どこまで理解していますか？
「名前解決してくれるやつ」くらいに思っていましたが、メールの認証で使われていたりといろいろと深い部分があるようです。
今回はDNSについて深堀って学んでみます。

## 1　ドメイン基礎

### 1.1　ドメイン名とIPアドレス

ドメイン名とは何でしょうか？

> ドメイン名とはインターネット上の住所のようなものです。

よくある説明ですね。
ドメイン名は人間が簡単にWebサイトなどにアクセスするために、IPアドレスの代わりに利用されます。

ドメイン名から対応するIPアドレスを得ることを**名前解決**と呼びます。
システム上でこの名前解決がうまく動作することでドメイン名を用いた検索などができます。

{{< admonition tip "IPアドレスによるメール送信" >}}

メール送信にもIPアドレスを利用することができます。
その場合、**hoge@[123.123.123.123]**のように[]をつけてIPアドレスを指定します。

※ gmail.comのmxレコードにあるドメインのIPアドレスを指定して送信してみましたが、アドレス不明と言われてしまいました。
Gmail自身がIPアドレス指定を許可していないのか、指定したサーバが異なるのか。
現状、理由は不明です。
{{< /admonition >}}


### 1.2　ドメインの管理

ドメイン管理において、重要な役割を担うのは以下です。
* ICANN
* レジストリ
* レジストラ

まず、レジストリについてです。
レジストリは".net"や".jp"などのトップレベルドメインを管理・運用している組織です。
現在1500以上のトップレベルドメインが存在し、一つのレジストリが複数のトップレベルドメインを管理・運用していたりします。

続いて、レジストラについてです。
レジストラはレジストリとユーザの間に入り、ドメイン名の登録やドメイン料金の徴収などを行います。
有名なレジストラには"お名前.com"などがありますね。

新たなドメイン名を利用したいときは、レジストラにドメイン登録申請を行うことで、レジストリに登録されることが分かりました。
では、トップレベルドメインを作ることは可能なのでしょうか？
ここで登場するのがICANNです。
ICANNはトップレベルドメインの審査・認可やレジストリ・レジストラの認定などを行っている組織です。
すなわちICANNがドメイン管理全体を統括しているようなイメージです。
トップレベルドメインの作成も一定の条件とお金が揃えば、ICANNに申請することで作成できるらしいです。


### 1.3　WHOIS

"WHOIS検索"を利用したことがある人も多いと思います。
僕も最初はWHOISっていうサービスを提供している団体がいるのだと思っていました。

実は、WHOISはプロトコルの名前です。
(仕組みのことをWHOISと呼ぶ場合もあるようです。)

WHOISはTCP/43番ポートを利用するプロトコルであり、ドメイン名やIPアドレスに関する情報を取得するために利用されます。
具体的には、登録者名や有効期限、レジストラ名、DNSサーバなどが分かります。
Linuxのコマンドからでも利用でき、その例が以下です。


{{< image src="whois-example.png" width="800px" height="600px" caption="WHOISコマンド" >}}

レジストリやレジストラの情報、更新日などもも見れますね。
続いて、WHOISのパケットも見てみましょう。

{{< image src="whois-packet-1.png" width="800px" height="600px" caption="WHOISクエリ" >}}
{{< image src="whois-packet-2.png" width="800px" height="600px" caption="WHOIS応答" >}}

WHOISにはDNSように様々な種類レコードがあったりしないため、クエリは非常にシンプルです。
それに対し、応答はテキスト形式の情報をたくさん返してきています。

非常にシンプルなプロトコルですね！

WHOISの登録はドメインの登録を行ったレジストリやレジストラに義務付けられています。
これにより、ドップレベルドメインのサーバへ問い合わせることでドメイン情報を取得できます。

{{< admonition tip "WHOISサーバの特定" >}}
実は先程のwhoisコマンド実行後、なぜか**whois.nic.io**にDNSクエリが送信されていました。

{{< image src="whois-packet-3.png" width="800px" height="600px" caption="WHOISサーバへの名前解決" >}}

これは、whoisクライアントにトップレベルドメインとそのwhoisサーバのドメインの対応表が登録されているためだそうです。

{{< /admonition >}}


## 2　DNS基礎

### 2.1　DNSとは？

DNSとは何でしょうか？まずは定義を見てみましょう。

> DNS(ディーエヌエス: Domain Name System)は、 インターネットの重要な基盤技術の一つで、 ドメイン名とIPアドレスの対応付けや、 メールの宛先ホストを指示するためのシステムです。

名前解決をするためのシステムということですね。

記事にはhosts.txsからDNSへとあることからも分かりますが、"/etc/hosts"はDNSではないようです。
システムではなく、テキストファイルという枠組みなのでしょう。

インターネット上のDNSという意味では、世界中のDNSサーバにより名前解決の仕組みが実現されるため、世界規模の分散型データベースととらえることもできます。


### 2.2　代表的なDNS製品

代表的なDNS製品には以下のようなものがあります。
* BIND\
OSSの最も有名なやつです。
* Unbound...キャッシュ専用のOSSです。
* PowerDNS...SQL連携できるOSSです。

* Microsoft DNS Server
* Amazon Route 53
* Cloudflare DNS


## 3　DNSの仕組み

### 3.1　ホストの名前解決の流れ

ここで、Linuxでの名前解決を復習しましょう。Linuxではnsswitch.confで名前解決の優先度が記載されています。

{{< image src="nsswitch-conf.png" width="800px" height="600px" caption="/etc/nsswitch.conf" >}}


> hosts: files dns

これは、名前解決の方法の順番を表しています。
アプリケーションのプロセスはlibcライブラリのgetaddrinfo()などから、名前解決を行なっています。
このとき、上記のような設定になっていると、まず"/etc/hosts"を確認し、名前解決できなかった場合はDNSに確認しに行きます。
ここでいうDNSは"/etc/resolv.conf"に記載されているものです。

"/etc/nsswitch.conf"に出てくる主なものとその意味は以下です。

* files.../etc/hostsに従って名前解決を行う
* dns.../etc/resolv.confに従ってDNSを利用した名前解決を行う
* mdns4...マルチキャストDNSを使って名前解決を行う
* mymachines...systemdによって管理されているローカルの仮想マシンやコンテナの名前解決を行う

{{< admonition Note "マルチキャストDNSとは"  >}}
マルチキャストDNS（mDNS）とはその名の通り、マルチキャストで利用するDNSです。
具体的には以下のような特徴があります。
* 同一セグメント内のみで有効
* マルチキャスト宛に送信
* 受け取ったノードが応答を返す
{{< /admonition >}}


### 3.2　DNSの名前解決の流れ

DNSには大きく2つの種類があります。
* 権威DNSサーバ
* キャッシュDNSサーバ

権威DNSサーバはゾーンファイルを持っています。
ゾーンファイルには、名前解決に必要なドメイン名とIPアドレスの組を始め、いくつかの情報を持っています。
権威DNSサーバはこのゾーンファイルの情報を利用し、名前解決に対し応答を行っています。

一方で、キャッシュDNSサーバはゾーンファイルを持ちません。
キャッシュDNSはDNS要求を受け取り、クライアントの変わりに再帰的に権威DNSサーバなどに名前解決を行い、結果をクライアントに返します。
キャッシュという名前にもある通り、過去のデータはキャッシュに保存しており、DNS要求を受け取った際にキャッシュにレコードを持っていれば、再起問い合わせなしにそのままクライアントに返すことができます。

DNSの種類が分かったところで、世の中のDNSの動きを見てみたいと思います。

{{< image src="resolv-conf.png" width="800px" height="600px" caption="/etc/resolv.conf" >}}

上の図は実際に名前解決をする流れです。

0. ローカルでの名前解決\
Webサイト訪問でも何でも良いですが、クライアントがドメイン名を利用し通信を行おうとした際、1.1で説明した"/etc/nsswitch.conf"に従った名前解決の方法で名前解決を試みます。

1. クライアントがDNSキャッシュサーバへDNS要求\
"/etc/nsswitch.conf"でDNSの順番が来た際は、"/etc/resolv.conf"に記載されたDNSサーバに対し順番に名前解決を試みます。
一般的なPC利用をしている場合はキャッシュDNSサーバに問い合わせが行われるはずです。

2. キャッシュDNSサーバによる名前解決\
クライアントからのDNS要求に対し、キャッシュを持っていればそれをそのまま返します。
キャッシュを持っていない場合は、ルートDNSサーバに再起問い合わせを行います。

3. ルートDNSサーバによる名前解決\
キャッシュDNSサーバからDNS要求を受け取った際、ルートDNSサーバは受け取ったDNS要求の上位ドメインのDNSサーバの情報を返します。
上の例で言うと、「jpドメインの情報ならhoge.dns.jpが持っているよ〜」みたいな感じです。

4. 権威DNSサーバによる名前解決\
受け取ったDNS要求に対し、自身がゾーン情報を持っている場合はその情報を返します。
3と同じように、DNS要求を受けたドメイン情報を持つ、さらに下位のDNSサーバの情報を返す場合もあります。

以上がDNSの仕組みです。
世の中での動きが分かると理解が深まりますね。

{{< admonition Note "キャッシュDNSサーバの登録"  >}}
普段キャッシュDNSサーバなんて意識せずに利用できています。
これはなぜでしょうか？

答えはDHCPプロトコルにあります。
PCはWifiなどに接続した際、DCHPによりIPアドレスやデフォルトGWの情報を受けとります。
実はこの際に、DNSサーバの情報も受け取ることが多いのです。
これにより、DNSサーバを自ら設定する必要がなくなります。

家庭用のルータを利用した際は、ルータ自身がキャッシュDNSとしての機能を持っていたり、ISPのキャッシュDNSが利用されていたりします。
{{< /admonition >}}


{{< admonition tip "ルートDNS" >}}
ルートDNSサーバは世界に13個あります。
日本にも存在し、m.root-servers.netがJPRS（株式会社日本レジストリサービス）によって運用されています。

※ 昔は僕の母校にもおいてあったらしい。。（驚）
{{< /admonition >}}

## 3　DNSレコード

では、DNSのゾーンファイルとはどのようなものでしょうか？
以下はOSSのDNSであるbind vにデフォルトで組み込まれたゾーンファイルのテンプレートです。


具体的なレコードについて例と一緒に見ていきましょう。

＊ Aレコード
```
example.com. IN A 192.168.0.1
```

最も一般的なレコードです。ドメイン名に対するIPアドレスを設定し、名前解決に利用されます。

＊ AAAAレコード
```
example.com. IN AAAA 2001:db8::1
```
IPv6用のAレコードです。

＊ CNAMEレコード
```
www.example.com. IN CNAME example.com.
```

ドメイン名のエイリアスを設定するためのレコードです。
最も簡単な例が上記のwww.example.comに訪れても、example.comに訪れるようにするという設定です。

なんとなく想像はつくかもしれませんが、クライアント（基本的にはキャッシュDNSサーバ）の動きとしては、返されたCNAMEに対し再びDNSクエリを送信します。

他にも以下のような例があります。

www.example.comのDNSクエリはCNAMEとしてlb.example.comを返します。lb.example.comは複数のAレコードを持っており、DNSクエリに応じて返すIPアドレスを変えることで負荷分散を行います。

＊ NSレコード
```
example.com. IN CNAME ns1.example.com
```

NSレコードはドメインを権威DNSサーバに委任するためのレコードです。
すなわち、example.comのドメイン情報はns1.example.comが持っているよーを返すためのレコードです。
CNAMEと同じようにクライアント(キャッシュDNSサーバ)はNSレコードを元に再度DNSクエリを送信します。

{{< admonition tip "ルートDNSサーバのゾーンファイル" >}}
ルートDNSサーバはトップレベルドメインのDNSサーバの情報を持っています。これにより、DNS要求を各トップレベルドメインのDNSサーバに委任するのです。
具体的なゾーンファイルは以下のようになっているみたいです。
{{< /admonition >}}


＊ MXレコード
```
example.com. IN MX 10 mail.example.com
```

MXレコードは送信先ドメインのメールサーバのドメインを得るためのレコードです。
メール送信時の流れは以下です。
1. 送信側のサーバはまずDNSに問い合わせてMXレコードを探す。
2. 見つかったMXレコードに記載されているメールサーバのドメインの名前解決を行う。\
※ すなわち、MXレコードで指定したドメインのAレコード/AAAAレコードも必要です。
3. 2で解決したIPアドレスにメールを送信する。

{{< admonition tip "DNSクエリのQuestion" >}}
DNSクエリに対し、IPアドレスを返す場合もあれば、メールサーバのドメイン名を返す場合もあると思います。
クライアントはこれをどのように要求し、DNSはどう見分けて返しているのでしょうか？

答えはDNSクエリの中にあります。
DNSエリにはQuestionセクションというセクションがあり、その中のTypeで要求するレコードタイプを指定します。
これにより、DNSは応答するレコードを判断しているのです。
{{< /admonition >}}

* TXTレコード

DNSのTXTレコードはドメインの情報を自由に記述するレコードです。
TXTレコードを利用したものとして、メールで利用されるSPFレコードやDKIMレコードが有名です。

* SPFレコード、DKIMレコード、DMARCレコード
この辺りはメールの送信ドメイン認証のために使われるレコードです。DNSのレコードタイプとしてはTXTです。
これらの詳細は「メールを完全に理解する」で確認しようと思います。今はテキストとしてメールのドメイン認証に使うレコードを持っているんだなくらいに思っておきましょう。

* SOAレコード

```
example.com. IN SOA ns1.example.com. hostmaster.example.com. (
2025041601 ; serial
3600 ; refresh
600 ; retry
604800 ; expire
86400 ; minimum
)
```

SOAとは「Start of Authority」の略です。権威の起点を示しています。
SOAレコードはゾーンに必ずに一つだけ存在し、ゾーンに関する様々な情報を保持しています。

上記の例の意味は以下です。
＊ ns1.example.com. ... プライマリDNSサーバ
＊ hostmaster.example.com. ... 管理者メールアドレス
＊ serial ... シリアル番号
＊ reflesh ... リフレッシュ間隔(秒)
＊ retry ... リトライ間隔(秒)
＊ expire ... 有効期限(秒)
＊ minimum ... キャッシュ最小TTL


* SRVレコード

```
_ldap._tcp.example.com. 3600 IN SRV 10 5 389 ldapserver.example.com.
```

SRVレコードでは、接続先のサービス情報を提供します。
上の例からは、以下のようなサービス情報が分かります。
* LDAPサーバ
* L4プロトコルはTCP
* 対象ドメインはexample.com
* ポート番号389
* ホスト名はldapserver.example.com

* CAAレコード

不正な証明書発行を防ぐためのものです。
詳細は7章のセキュリティの文脈で説明します。

* RSIGレコード

ドメイン認証に利用されるレコードです。
詳細は7章のセキュリティの文脈で説明します。

## 4　運用者からみたDNS

ここで、よりイメージを具体化するためにDNS/ドメインの運用を見てみましょう。
ここでは、適当に立てたWebサーバを外部に公開し、ドメイン名でアクセスできるようにするケースを考えます。

0. 公開Webサーバの準備
ここでは詳しい説明は飛ばします。Webサーバを立て、外部からIPアドレスでアクセスできるようにします。

1. ドメインの取得
まずはドメインを取得します。
この時に利用するのがレジストラです。
有名なレジストラとしては"お名前.com"などがありますね。
以下はお名前.comでドメインを取得するときの画面です。


{{< image src="onamaecom-domain.png" width="800px" height="600px" caption="お名前.comの写真" >}}

このように、ドメイン名によっては無料で取得できるものも多くあります。アカウントさえ登録すれば、簡単にドメインを取得できます。

2. DNSへの登録
前節であったようなレコードをDNSにサーバに登録する必要があります。DNSサーバの登録では大きく2つの分岐があります。

＊ 自前DNSサーバを利用する\
自分でDNSサーバを用意し、そこにゾーンファイルを置きます。
＊ 他社のDNSに相乗りする\
他社のDNSにレコードを登録します。今回の例だと簡単なのはレジストラが提供しているDNSサーバを利用する方法です。
以下がお名前.comのDNSサーバの登録画面です。

{{< image src="onamaecom-dns.png" width="800px" height="600px" caption="お名前.comの登録画面" >}}


レジストラが提供するDNSサーバ以外の例として、クラウドが提供するDNSサーバがあります。
クラウドでWebサーバを構築している場合はそちらに登録するのが良いと思います。

3. DNSレコードの伝播/アクセス確認

DNSレコードの伝播には時間がかかる可能性があります。
これはキャッシュDNSサーバが古いレコードの情報を持っている可能性があるためです。
DNSキャッシュサーバはDNSレコードに記載されているTTL(Time to Live)の時間が経つまでは再起問い合わせを行わずキャッシュのデータを返します。
このためDNSキャッシュサーバのキャッシュが更新されるまで待つ必要があるのです。

DNSレコードの伝播が終われば、アクセス確認をして終わりです。



{{< admonition tip "DDNS" >}}
DDNSとはDynamic DNSの略です。自宅鯖とかでよく見ますね。
DDNSは、ISPから割り当てられた動的IPアドレスをドメインに紐づけるためにあります。これにより、サーバのIPアドレスが変わっても同じドメインでアクセスできるようになります。

仕組みとしては単純です。サーバ側でWAN側IPが変わった時にDDNSサーバに対し、IPアドレスが変わったことを通知し、DDNSがドメインに対応するIPを書き換えるのです。ここでは主にHTTPリクエストでAPIを叩く方式が利用されているようです。
{{< /admonition >}}

{{< admonition tip "IDNAとは" >}}
IDNAは日本語ドメイン名などの非ASCII文字をドメイン名として使えるようにする仕組みです。
具体的には、日本語などの非ASCII文字を**Punycode（ピュニコード）**と呼ばれる特殊なASCII文字列に変換してDNSクエリを送信します。

実際にJPRSのIDNテスト用ドメインの名前解決をした例が以下です。
{{< image src="idna.png" width="800px" height="600px" caption="日本語ドメインの検索" >}}

{{< /admonition >}}

{{< admonition Note "運用目線でのDNSの種類" >}}
DNSを運用する際、大きく以下の種類に分類できます。
* Internal DNS
    * 内部ネットワークに配置
    * 内部ドメインの名前解決
    * インターネットへの名前解決
* Forwarder DNS
    * Internal DNSからインターネットへの名前解決
* External DNS
    * 自社ドメイン宛の名前解決
* Hidden Primary DNS
    * 全DNSのマスタデータを保持
{{< /admonition >}}



## 5　DNSの通信

### 5.1　ヘッダフォーマット

DNSはクエリとレスポンスが同じフォーマットを利用します。

大きく分けると以下のセクションに分割されます。

| セクション |  サイズ   |  用途   |
|------------|-----------|---------|
| Header     |  12バイト |  クエリ/応答に関する情報       |
| Question   |  可変     |  対象のドメイン名とレコードタイプの指定       |
| Answer     |  可変     |  リクエストに応じたレコード       |
| Authority  |  可変     |  再起問い合わせで使用されるNSレコードのリスト       |
| Additional |  可変     |  追加のレコード(NSレコードに対するAレコードなど)       |

Headerセクションは以下です。

|   RFC名  |    名前                   | サイズ         |  説明                                                                         |
|----------|---------------------------|----------------|-------------------------------------------------------------------------------|
|  ID      |    Packet Identifier      |  16ビット      |   ランダムなID                                                                |
|  QR      |    Query Response         |    1ビット     |    リクエストは0、レスポンスは1                                               |
|  OPCODE  |    Operation Code         |    4ビット     |     問い合わせの種類であり、通常は0（Notifyが4、Updateが5だったりするらしい） |
|  AA      |    Authoritative Answer   |  1ビット       |   応答するサーバが権威サーバであれば1                                         |
|  TC      |    Truncated Message      |    1ビット     |    パケットサイズが512を超えるならば1                                         |
|  RD      |    Recursion Desired      |    1ビット     |    再帰的な名前解決をするかリクエストの送信側が指定する                       |
|  RA      |    Recursion Available    |  1ビット       |    再帰的な名前解決が可能ならば1                                              |
|  Z       |    Reserved               |   1ビット      |     予約                                                                      |
|  AD      |    Authentic Data         |   1ビット      |     DNSSECの検証成功時に1                                                     |
|  CD      |    Checking Disabled      |   1ビット      |     DNSSECの検証成功時に1                                                     |
|  RCode   |    Response Code          |   4ビット      |   サーバがレスポンスの状態をクライアントに提示するためのコード                |
|  QDCOUNT |    Question Count         |   16ビット     |   Questionセクションのエントリ数                                              |
|  ANCOUNT |    Answer Count           |   16ビット     |     ANCOUNTセクションのエントリ数                                             |
|  NSCOUNT |    Authority Count        |    16ビット    |      NSCOUNTセクションのエントリ数                                            |
|  ARCOUNT |    Additional Count       |   16ビット     |     ARCOUNTセクションのエントリ数                                             |


Questionセクションは以下です。

|   フィールド名  |  サイズ         |     説明                 |
|-----------------|-----------------|--------------------------|
|   Name          |    可変         |    ドメイン名            |
|   Type          |    2バイト      |     レコードタイプ       |
|   Class         |    2バイト      |     クラス（基本的には1）|


Anser/Authority/Additionalセクションは以下です。

|   フィールド名  |  サイズ         |     説明                    |
|-----------------|-----------------|-----------------------------|
|   Name        |    可変           |    ドメイン名               |
|   Type        |    2バイト        |     レコードタイプ          |
|   Class        |    2バイト       |     クラス（基本的には1）   |
|   TTL        |    4バイト         |     レコードのキャッシュ時間|
|   Len        |    2バイト         |     レコード長              |


{{< admonition tip "レコードのクラス" >}}
DNSのパケットにクラスがでてきました。

これは下のようなゾーンファイルでもでてくる"IN"のことです。

```
example.com. IN MX 10 mail.example.com
```

"IN"はインターネットを表し、インターネットで使われることを意味します。
他にも、"CH"や"HS"がありますが、"CH"は歴史的なもの、"HS"は特殊用途で利用されるものであるため、"IN"以外を見ることはまずないといえます。

{{< /admonition >}}


### 5.2　パケット解析

では、実際にnslookupコマンドやdigコマンドでDNSパケットを見てみましょう。

nslookupでgithub.ioの名前解決をしてみます。
nslookupではデフォルトでA/AAAAレコードを指定してDNSクエリを送信します。

{{< image src="dns-query-a-record.png" width="800px" height="600px" caption="nslookup" >}}
{{< image src="dns-packet-a-record-1.png" width="800px" height="600px" caption="A/AAAAレコードのDNSクエリ" >}}
{{< image src="dns-packet-a-record-2.png" width="800px" height="600px" caption="A/AAAAレコードのDNS応答" >}}

次に、digでANYを指定してDNSクエリを送信してみます。

{{< image src="dns-dig.png" width="800px" height="600px" caption="dig" >}}
{{< image src="dns-packet-dig-1.png" width="800px" height="600px" caption="ANY指定のDNSクエリ" >}}
{{< image src="dns-packet-dig-2.png" width="800px" height="600px" caption="ANY指定のDNS応答" >}}


{{< admonition tip "ANYレコードの制限" >}}
最近のDNSサーバではANYクエリに対する応答に制限をかけていることが多いです。
これは、反射型DoSに利用されることを防止するためや負荷対策のためです。
DNS通信にはUDPが利用され、送信元を偽造できる他、応答のレコードが多いとデータ量が数十倍から数百倍になります。
このため、効率よくDoS攻撃に利用することができるのです。
{{< /admonition >}}


{{< admonition tip "DNS Cookie" >}}
先程のDNSパケットに含まれていたDNS Cookieとは何でしょうか？
僕もこの記事を書くまでは存在すら知りませんでした。
DNSはUDPでステートレスなのになぜCookie？という感じの人も多いと思います。
{{< image src="dns-cookie.png" width="800px" height="600px" caption="DNS Cookie" >}}

DNS Cookieとは、その名の通りDNSパケットに付与するCookieのことです。
これにより、クエリを送信したユーザを識別します。
これには、以下のようなメリットがあります。

* 反復型DoS攻撃の防止\
DNSはANYレコードの件でも述べたとおり反復型DoS攻撃に利用されやすいです。
この場合、送信者は送信元を偽造するためサーバ側のCookieを知ることはできません。
この性質を利用して、サーバ側では同じ送信元の2回目以降のクエリに対し、Cookieが入っていない場合はパケットを破棄するという処理を行うことができます。
これにより、反復型DoS攻撃への利用を防ぐことができます。
* キャッシュポイズニング\
DNSキャッシュサーバは権威DNSサーバにCookie付きでDNSクエリを送信し、応答にCookieが含まれているかを確認することで、キャッシュポイズニングを防止することができます。
{{< /admonition >}}


## 6　可用性

### 6.1　監視

DNSに限らず一般的な話です。
正常性を監視し、以上があれば別のサーバにトラフィックを切り替えたりします。

### 6.2　負荷分散

地理的に異なる場所にDNSサーバを配置し、Anycastなどを用いて、地理的に近いDNSサーバで応答させ、負荷分散を図ります。
他にも、単純にサーバを複数用意するなどして負荷分散を図ります。

### 6.3　冗長化

DNSの可用性確保の大きな方針として冗長化が挙げられます。

DNSサーバではプライマリDNSサーバとセカンダリDNSサーバなど複数のDNSサーバを用意し、ゾーンファイルを同期させることで、単一障害点をなくすことが一般的です。
これにより、プライマリDNSサーバが落ちたとしても、セカンダリDNSサーバがDNS応答を行ってくれます。

ゾーン情報の同期はセカンダリDNSサーバがプライマリDNSサーバに定期的にゾーン転送要求を行うことで行われます。

ゾーン転送には以下の2種類があります。
* フルゾーン転送（AXFR）...DNSゾーン全体を転送
* インクリメンタルゾーン転送（IXFR）...前回の転送以降に変更されたレコードのみを転送


{{< admonition tip "ゾーンファイル転送のプロトコル" >}}
ゾーン転送にもDNSクエリと同じDNSプロトコルが利用されているのでしょうか？
基本的にゾーン転送は許可されたDNSサーバへしか許可されていないので、ここでは教育目的などで公開されている
**zonetransfer.me**に対し、クライアントPCからゾーン転送要求を送信してみます。

{{< image src="dns-axfr-1.png" width="800px" height="600px" caption="ゾーンファイル要求" >}}
{{< image src="dns-axfr-2.png" width="800px" height="600px" caption="ソーンファイル応答" >}}

DNSにおけるゾーンファイルのやりとりにはDNSクエリと同じDNSプロトコルが利用され、以下の拡張仕様が利用されます。
* AXFR(Full Zone Transfer)\
ゾーン全体を一括で転送する。
* IXFR(Incremental Zone Transfer)\
差分のみを転送する。

これらの仕様ではパケットサイズがおおきくなるためTCPが利用されています。
{{< /admonition >}}


## 7　セキュリティ

DNSのセキュリティについて、攻撃と防御という観点でまとめていきます。

### 7.1　ゾーン転送要求による偵察

DNSを利用した標的の偵察活動として、**ゾーン転送要求**があります。

権威サーバのゾーンファイルには、公開しているレコード以外にも、内部向けのホスト名などレコードなどが含まれます。
攻撃者はゾーン転送要求によりゾーンファイルを取得することで、標的のネットワーク構成やプライベートなホスト名などを知ることができます。

基本的な対策としては、ゾーン転送の送信相手を制限することです。
具体的には、以下のような対策があります。

* アクセス許可リスト\
DNSサーバの設定として、アクセス制御をかけることができます。\
※ Bindだと"acl"や"allow-transfer"などがあります。
* TSIG\
共通鍵暗号によりDNSサーバ間の通信にHMAC署名を加えることで改ざんと偽造を防ぎます。

{{< admonition Note "TSIG" >}}
TSIGはTransaction Signatureの略で事前共有鍵によるHMACベースの署名を行うものです。
具体的には、
1. 送信者はゾーンファイルなどの平分に対し、事前共有鍵を用いてメッセージ認証コードを計算し、メッセージと一緒に送信します。
2. 受信者は受信したメッセージに対し、同じように事前共有鍵でメッセージ認証コードを計算し、受信したメッセージ認証コードと一致するかを確認します。

事前共有鍵を持っていない場合は正しいメッセージ認証コードを作成できないため、以下を実現できます。

* 認証
* 改ざん防止
* アクセス制御

以下は、実際にTSIGを利用する際のマスターDNSの設定です。
```
key "tsig-key" {
    algorithm hmac-sha256;
    secret "VHJhbnNhY3Rpb24gU2lnbmF0dXJl";
};

zone "example.com" IN {
    type master;
    file "example.com.zone";
    allow-transfer { key tsig-key; 192.0.1.1; };
};
```
{{< /admonition >}}

#### 7.2　DNS応答の偽造

基本的に人間はドメイン名による検索を行います。
この際に名前解決が発生するわけですが、DNSの情報が改ざんされるなどした場合、ユーザはフィッシングのように偽のサイトに誘導されてしまいます。
このような攻撃を**ファーミング**と呼びます。

ここではファーミングの手法として、**DNSキャッシュポイズニング**を紹介します。

DNSキャッシュポイズニングはDNSキャッシュサーバに不正なキャッシュを保存させ、名前解決時に悪意のあるサイトに誘導する攻撃です。

DNSキャッシュポイズニングの1例として、権威サーバからのキャッシュサーバへの応答偽装があります。DNSの通信はUDPで行われるため、キャッシュサーバから権威サーバへのDNSクエリの応答を権威サーバより早く返すことができれば、DNSキャッシュサーバに悪意のあるドメイン情報を保存することができます。

DNSキャッシュポイズニングの具体的な攻撃手法としてカミンスキー攻撃があります。5.1節でdnsパケットのヘッダセクションには"packet identioier"が含まれていたことを覚えているでしょうか？DNSキャッシュサーバは権威サーバからのDNS応答の正当性をDNSクエリに含めた"packet identifier"と同じものがDNS応答に付与されているかで判断します。しかし、DNSプロトコルの"packet identifier"は16ビットであり、65536通りしか存在しません。これにより、IDを総当たりで試していけば高速で"packet idntifier"を一致させたDNS応答を送信することができます。カミンスキー攻撃はDNSプロトコルの脆弱性を利用した攻撃と言えます。

具体的なカミンスキー攻撃の流れを以下に示します。

カミンスキー攻撃の流れは以下です。
1. キャッシュDNSサーバに対し、キャッシュがないレコードのDNSクエリを送信する。
2. 1の応答として、偽のDNS応答を"packet identifier"を総当たりで変えながらキャッシュDNSサーバに送信する。
3. 1,2を大量に繰り返す。

{{< admonition Note "ソースポートランダマイゼーション" >}}
カミンスキー攻撃の対策として、ソースポートランダマイゼーションがあります。

ソースポートランダマイゼーションはその名の通り、送信元のポート番号をランダムに変更する手法です。
キャッシュDNSサーバが送信元ポート番号をランダムに変えながら権威DNSサーバにDNSクエリを送信することで、攻撃者は"packet identifier"以外にポート番号も当てる必要があります。

ソースポートランダマイゼーションが適用されたキャッシュDNSサーバに対し攻撃を成功させるためには、"packet identifier"とポート番号の組み合わせの32ビット分を一致させたDNS応答を権威DNSサーバからの応答より早くキャッシュDNSサーバに送信する必要があります。
{{< /admonition >}}

{{< admonition Note "DNSSEC" >}}
DNSSEC（Domain Name System Security Extension）とは、電子署名によりDNS応答の改ざんや偽造を防止する機能です。
具体的には、権威DNSサーバがDNSのレコードに対し電子署名を付与し、DNSレコードを取得したキャッシュDNSサーバなどが署名を検証することで正しいレコードであることを確認します。
DNSSECは署名によりレコードの改ざんや偽造を防止できるため、DNSキャッシュポイズニングの根本的な対策として有効です。

先に、署名がどのようなものなのか見てみましょう。
"cloudflare.com"のAレコードとそのRRSIGレコードを取得してみます。

{{< image src="rrsig.png" width="800px" height="600px" caption="RRSIGレコード" >}}

以下の部分が署名です。（Base64でエンコードされています。）
これを検証することでDNSレコードの正当性を確認できます。
```
5hxMxgVw61o68xcQvUFXbPXpVO5ErWKZgU+IOAA8ArN87vkykItKLX/d uk49LZ90TprobmOmZ9d1B2zs0TMnKQ==
```

具体的な署名を確認したところで、DNSSECの署名検証について全体の動きを見てみましょう。
1. キャッシュDNSサーバが権威DNSサーバにDNSクエリを送信する。
2. 権威DNSサーバはキャッシュDNSサーバにAレコードとRRSIGレコードを返す。
3. キャッシュDNSサーバはRRSIGレコードを検証するための公開鍵を得るために権威DNSサーバにDNSKEYレコードを問い合わせる。
4. DNSKEYの正当性を検証するために親ゾーンのDSレコードを取得し、DNSKEYから計算したハッシュ値と比較する。
5. 同様に親ゾーンのレコードを検証。
6. 最後にルートゾーンの公開鍵をあらかじめインスールされているものと比較する。

上記のように、DNSSECの検証では、レコードの署名を検証する際の公開鍵に対し、上位のDNSサーバが正しさを証明し、最終的にルートDNSサーバの公開鍵と比較することで正当性を確認します。
これを信頼の連鎖と呼びます。

実際に先程の"cloudflare.com"のRRSIGを検証する流れを見てみます。

まずは、RRSIGレコードにある署名を検証するために、公開鍵を取得します。
{{< image src="dnskey.png" width="800px" height="600px" caption="DNSKEYレコード" >}}

キャッシュDNSサーバはこのDNSKEYで先程のAレコードのRRSIGレコードを検証します。
これにより、Aレコードの正当性を確認できます。
DNSKEYにもRRSIGがあります。

次に、そもそもDNSKEYが正しいかを確認します。
{{< image src="ds.png" width="800px" height="600px" caption="DSレコード" >}}

"@a.gtld-servers.net"は.comの権威DNSサーバの一つです。
取得したDSレコードと先程のDNSKEYのハッシュ値を比較することで、DNSKEYの正当性を確認します。

以降は、DSレコードのRRSIGレコードをDNSKEYで検証し、そのDNSKEYをルートDNSサーバのDSレコードと比較するといった流れです。

{{< /admonition >}}


#### 7.2　DoS

権威DNSサーバへのDoS攻撃として、**ランダムサブドメイン攻撃（DNS水攻め攻撃）**があります。
これは、標的となる権威DNSサーバに対し、キャッシュDNSサーバにキャッシュがないサブドメインを大量に問い合わせることで、権威DNSサーバに負荷をかける攻撃です。

具体的には、"example.com"の権威DNSサーバを攻撃しようとした際は、"hoge.example.com"や"huga.example.com"といったキャッシュDNSサーバに
キャッシュが存在しないサブドメインをキャッシュDNSサーバに問い合わせることで、権威DNSサーバに大量の問い合わせを集中させます。

ランダムサブとメイン攻撃への対策としては以下のようなものがあります。
* レートリミット\
一定時間内の同じクライアントからのリクエストを制限する
* NXDOMAINキャッシュ\
「レコードがない」という応答をキャッシュさせる。
* DNS Cookieの強制\
応答を正当なクライアントのみに制限する。

DoS攻撃については、DNS自身への攻撃の他にDNSを利用された外部へのDoS攻撃があります。
**DNSリフレクション（アンプ）攻撃**がその一つです。

DNSアンプ攻撃は、応答が大きくなるようなDNSクエリを送信元を標的のアドレスにした上で大量に送信し、DNS応答で標的サーバに負荷をかける攻撃です。

この攻撃が成立する一つの原因として、DNSがUDPを利用した通信であるため、送信元を偽造できることがあります。
また、DNSの「リクエストに対しレスポンスを大きくしやすい」という性質もこの攻撃を後押しする原因の一つです。
ANYレコードやDNSSEC関連のレコードなどはリクエストに対しレスポンスが大きくなり、効率的にDoS攻撃に利用することができます。

では、DNSリフレクション（アンプ）攻撃の対策はどうすれば良いのでしょうか？
根本的な対策は以下です。
* 社内のキャッシュサーバを公開しない
* 権威サーバでは再帰問い合わせを許可しない

しかし、DNSサーバには利用者を限定しない公開する目的で運用される場合も多くあります。
この場合の対策としては以下が考えられます。

* レートリミット\
一定時間内の同じクライアントからのリクエストを制限する
* 応答サイズの制限\
"minimal-response"を設定することで必要最低限の応答しか返さないようにしたり、
EDNSサイズを制限することでUDPで応答可能な最大サイズを小さくしたりする。
* プロバイダのDoS対策\
BGPのフィルタリングやUDPレートの制限などプロバイダ側で対策してもらう。
* DNS Cookie\
DNS Cookieにより、複数回のクエリにはCookieを求めることで送信元が偽造されたパケットには応答しないようにする。


#### 7.3　情報漏えい

DNSを利用した情報漏えい手法に**DNSトンネリング**があります。
DNSトンネリングの流れは以下です。
1. 攻撃者がドメインをレジストラに登録
2. 攻撃者が権威DNSサーバを構築
3. 攻撃者（内部不正など）やマルウェアに感染した端末が機密情報を1で登録したドメインのサブドメインとして付与し、DNSクエリとして送信。
4. 2の権威DNSサーバで受信したDNSクエリから3の機密情報を取得

DNSトンネリングはサーバと直接通信するわけではないため、DNSホワイトリストなどのフィルタリングにも検知されず情報漏えいに効果的です。
これを防ぐためにはDNSクエリを監視する必要があります。


#### 7.4　DNSクエリの盗聴

通常、DNSクエリはUDP上で平文で流れるため、ユーザがどこのサイトに訪れているかなどが通信から見られてしまいます。
ここで、DNSクエリを暗号化するのが**DNS over TLS**です。

DoT（DNS over TLS）はDNSの名前解決をHTTPSで行います。
これにより、DNSクエリを暗号化できるほか通常のHTTPSと同じく、通信相手（サーバ）の認証や改ざん対策にもなります。

それでは、実際にDoT通信を見てみましょう。
digコマンドではDoTに対応した名前解決ができないため、kdigコマンドを利用します。
{{< image src="kdig.png" width="800px" height="600px" caption="kdigコマンド" >}}
{{< image src="secure-dns-packet.png" width="800px" height="600px" caption="DoTを適用したDNSクエリ" >}}

DNSサーバとして指定した"1.1.1.1"のサーバ（CloudFlareのDNSサーバ）との通信がTLSになっていることが分かります。
これにより訪問したサイトもばれずにすみます！

ChromeでもSecure DNSの設定がありました。
{{< image src="secure-dns-setting.png" width="800px" height="600px" caption="ブラウザでのDoTの設定" >}}



{{< admonition tip "パッシブDNS" >}}
パッシブDNSとは、**過去のドメインとIPアドレスの対応状況**を記録・保存しておく仕組みです。
仕組みとしては、定期的に名前解決を行い対応表を作るわけではなく、キャッシュDNSサーバのクライアントへの応答を記録しておく形です。

パッシブDNSはセキュリティ調査で利用され、怪しい名前解決からマルウェアの通信先の履歴をたどることなどができます。
{{< /admonition >}}


{{< admonition tip "Fast FluxとDomain Flux" >}}
攻撃に利用されるDNSに関連した技術として**Fast Flux**と**Domain Flux**があります。
* Fast Flux\
一つのドメイン名に対し、IPアドレスを高速で次々に変える仕組みです。
仕組みとしては、攻撃者が権威DNSサーバを用意し、名前解決に対する応答を大量のボットなどのIPから都度変えながら返します。
これにより、ボットなどのサーバをプロキシとして利用するなどして、C&Cサーバの場所を特定しにくくします。
* Domain Flux\
一つのIPアドレスに対し、ドメインを高速で次々に変える仕組みです。
仕組みとしては、大量のドメインを登録しておき、時間やその他の規則ベースでマルウェアなどの接続先ドメイン名を変更します。
これにより、企業のブラックリストなどを回避します。
{{< /admonition >}}

## 8　まとめ

今回はDNSについて、世の中の名前解決の動きや通信から学習しました。
セキュリティについては詳しく学びましたが、その他の部分はあまり深掘れていないので、時間があるときに追加で執筆しようと思います。
bindを触ってみる内容の記事もいずれ書きたいと思います。


{{< admonition Note "（補足）NIST SP 800-81r3"  >}}
NISTがDNSのベストプラクティスを公開しているようです。
* [Secure Domain Name System (DNS) Deployment Guide](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-81r3.ipd.pdf)
私も時間を見つけて読もうと思います。
{{< /admonition >}}


## 参考

[1] [インターネット10分講座：DNS](https://www.nic.ad.jp/ja/newsletter/No22/080.html)
[2] [Building a DNS server in Rust](https://github.com/EmilHernvall/dnsguide/tree/master)
[3] [バイナリを読み解いて学ぶDNSパケットの構造](https://zenn.dev/gorogoroumaru/articles/00ca59c178535e)
[4] [DNS トンネリングとは](https://www.akamai.com/ja/glossary/what-is-dns-tunneling#:~:text=DNS%20%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AF%E3%80%81%E3%83%8F%E3%83%83%E3%82%AB%E3%83%BC%E3%81%8C,%E5%9B%9E%E9%81%BF%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%82%88%E3%81%8F%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82)
[5] [DNS over TLS vs. DNS over HTTPS | 安全なDNS](https://www.cloudflare.com/ja-jp/learning/dns/dns-over-tls/)

